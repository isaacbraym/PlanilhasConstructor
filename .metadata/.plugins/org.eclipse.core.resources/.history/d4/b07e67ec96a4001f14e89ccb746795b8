package com.abnote.planilhas.impl;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.Arrays;
import java.util.List;
import java.util.regex.Pattern;

import org.apache.poi.ss.usermodel.Cell;
import org.apache.poi.ss.usermodel.CellType;
import org.apache.poi.ss.usermodel.Row;
import org.apache.poi.ss.usermodel.Sheet;
import org.apache.poi.ss.usermodel.Workbook;

import com.abnote.planilhas.estilos.EstiloCelula;
import com.abnote.planilhas.interfaces.IPlanilha;
import com.abnote.planilhas.utils.PosicaoConverter;

public abstract class PlanilhaBase implements IPlanilha {
    protected Workbook workbook;
    protected Sheet sheet;
    private int posicaoInicialColuna = 0;
    private int posicaoInicialLinha = 0;
    private int posicaoFinalColuna = 0; // Novo campo para coluna final
    private int posicaoFinalLinha = 0;   // Novo campo para linha final
    private Integer lastInsertedColIndex = -1;
    private String diretorioSaida = "C:\\opt\\tmp\\testePlanilhaSaidas"; // Diretório padrão

    // Rastreia a última linha inserida
    private int lastInsertedRowIndex = -1;

    // Flags para verificar se naCelula ou noIntervalo foi chamado
    private boolean posicaoDefinida = false;
    private boolean intervaloDefinido = false;

    protected abstract void inicializarWorkbook();

    @Override
    public void criarPlanilha(String nomeSheet) {
        inicializarWorkbook();
        sheet = workbook.createSheet(nomeSheet);
        // Resetar posição ao criar uma nova planilha
        resetarPosicao();
    }

    @Override
    public void criarSheet(String nomeSheet) {
        if (workbook.getSheet(nomeSheet) != null) {
            throw new IllegalArgumentException("A aba '" + nomeSheet + "' já existe!");
        }
        sheet = workbook.createSheet(nomeSheet);
        // Resetar posição ao criar uma nova sheet
        resetarPosicao();
    }

    @Override
    public void SELECIONAR_SHEET(String nomeSheet) {
        try {
            if (workbook == null) {
                throw new IllegalStateException("Workbook ainda não foi inicializado!");
            }

            sheet = workbook.getSheet(nomeSheet); // Tenta obter a aba pelo nome

            if (sheet == null) {
                throw new IllegalArgumentException("A aba '" + nomeSheet + "' não foi encontrada.");
            }

            // Resetar posição ao selecionar uma nova sheet
            resetarPosicao();

        } catch (IllegalArgumentException e) {
            System.err.println(
                    "Erro: A aba '" + nomeSheet + "' não foi criada. Verifique a chamada do método criarSheet().");
            throw e;
        }
    }

    @Override
    public IPlanilha naCelula(String posicao) {
        int[] indices = converterPosicao(posicao);
        this.posicaoInicialColuna = indices[0];
        this.posicaoInicialLinha = indices[1];
        this.posicaoDefinida = true; // Marca que a posição foi definida
        this.intervaloDefinido = false; // Reseta o intervalo se naCelula for chamado
        return this;
    }

    @Override
    public IPlanilha noIntervalo(String posicaoInicial, String posicaoFinal) {
        int[] inicio = converterPosicao(posicaoInicial);
        int[] fim = converterPosicao(posicaoFinal);

        // Validação básica para garantir que o intervalo é válido
        if (inicio[1] > fim[1] || inicio[0] > fim[0]) {
            throw new IllegalArgumentException("Posição inicial deve ser menor ou igual à posição final.");
        }

        // Armazena os índices do intervalo
        this.posicaoInicialLinha = inicio[1];
        this.posicaoInicialColuna = inicio[0];
        this.posicaoFinalLinha = fim[1];
        this.posicaoFinalColuna = fim[0];
        this.intervaloDefinido = true; // Flag indicando que um intervalo foi definido
        this.posicaoDefinida = false; // Reseta a posição individual se noIntervalo for chamado

        return this;
    }

    @Override
    public IPlanilha inserirDados(String valor) {
        // Verifica se a posição foi definida por naCelula()
        if (posicaoDefinida) {
            inserirDadosNaPosicao(valor);
        } else if (intervaloDefinido) {
            throw new IllegalStateException("Intervalo definido. Utilize métodos apropriados para inserção em intervalos.");
        } else {
            // Nenhuma posição ou intervalo definido, insere na célula A1
            inserirDadosNaPosicao(valor, 0, 0);
        }

        return this;
    }

    @Override
    public IPlanilha inserirDados(Object dados, String delimitador) {
        if (dados instanceof List) {
            @SuppressWarnings("unchecked")
            List<String> lista = (List<String>) dados;
            inserirDados(lista, delimitador);
        } else if (dados instanceof String) {
            String str = (String) dados;
            if (Files.exists(Paths.get(str))) {
                inserirDadosArquivo(str, delimitador);
            } else {
                // Insere como uma única célula ou divide pelo delimitador
                inserirDados(Arrays.asList(str.split(delimitador)), delimitador);
            }
        } else if (dados instanceof File) {
            inserirDadosArquivo(((File) dados).getPath(), delimitador);
        } else {
            throw new IllegalArgumentException("Tipo de dados não suportado: " + dados.getClass());
        }
        return this;
    }

    @Override
    public IPlanilha inserirDados(List<String> dados) {
        // Similar ao inserirDados(String valor)
        // Implementação pode variar conforme a lógica necessária
        // Aqui está uma implementação simples
        if (posicaoDefinida) {
            inserirDadosNaPosicao(dados);
        } else if (intervaloDefinido) {
            throw new IllegalStateException("Intervalo definido. Utilize métodos apropriados para inserção em intervalos.");
        } else {
            // Nenhuma posição ou intervalo definido, insere na linha 1
            inserirDadosNaPosicao(dados, 0, 0);
        }

        return this;
    }

    @Override
    public IPlanilha inserirDados(List<String> dados, String delimitador) {
        // Similar ao inserirDados(List<String> dados)
        if (posicaoDefinida) {
            inserirDadosNaPosicao(dados, delimitador);
        } else if (intervaloDefinido) {
            throw new IllegalStateException("Intervalo definido. Utilize métodos apropriados para inserção em intervalos.");
        } else {
            // Nenhuma posição ou intervalo definido, insere na linha 1
            inserirDadosNaPosicao(dados, delimitador, 0, 0);
        }

        return this;
    }

    @Override
    public IPlanilha inserirDadosArquivo(String caminhoArquivo, String delimitador) {
        // Verifica se a posição foi definida por naCelula() ou noIntervalo()
        if (posicaoDefinida) {
            inserirDadosArquivoNaPosicao(caminhoArquivo, delimitador);
        } else if (intervaloDefinido) {
            throw new IllegalStateException("Intervalo definido. Utilize métodos apropriados para inserção em intervalos.");
        } else {
            // Nenhuma posição ou intervalo definido, insere a partir da célula A1
            inserirDadosArquivoNaPosicao(caminhoArquivo, delimitador, 0, 0);
        }

        return this;
    }

    private void inserirDadosNaPosicao(String valor) {
        inserirDados(valor, posicaoInicialColuna, posicaoInicialLinha);
        resetarPosicao();
    }

    private void inserirDadosNaPosicao(String valor, int coluna, int linha) {
        Row linhaAtual = sheet.getRow(linha);
        if (linhaAtual == null) {
            linhaAtual = sheet.createRow(linha);
        }
        Cell celula = linhaAtual.createCell(coluna);
        celula.setCellValue(valor);

        lastInsertedRowIndex = linha;
        lastInsertedColIndex = coluna;

        // Após inserir, reseta a flag
        resetarPosicao();
    }

    private void inserirDados(List<String> dados, String delimitador) {
        if (posicaoDefinida) {
            inserirDadosNaPosicao(dados, posicaoInicialColuna, posicaoInicialLinha);
            resetarPosicao();
        } else {
            // Implementação para intervalos pode ser adicionada se necessário
            throw new UnsupportedOperationException("Inserção de dados em intervalos não está implementada.");
        }
    }

    private void inserirDadosNaPosicao(List<String> dados, int coluna, int linha) {
        Row linhaAtual = sheet.getRow(linha);
        if (linhaAtual == null) {
            linhaAtual = sheet.createRow(linha);
        }
        for (int i = 0; i < dados.size(); i++) {
            Cell celula = linhaAtual.createCell(coluna + i);
            celula.setCellValue(dados.get(i));
        }
        lastInsertedRowIndex = linha;
        posicaoInicialLinha++;

        // Após inserir, reseta a flag
        resetarPosicao();
    }

    private void inserirDados(List<String> dados, String delimitador, int coluna, int linha) {
        Row linhaAtual = sheet.getRow(linha);
        if (linhaAtual == null) {
            linhaAtual = sheet.createRow(linha);
        }
        for (int i = 0; i < dados.size(); i++) {
            Cell celula = linhaAtual.createCell(coluna + i);
            celula.setCellValue(dados.get(i));
        }
        lastInsertedRowIndex = linha;
        posicaoInicialLinha++;

        // Após inserir, reseta a flag
        resetarPosicao();
    }

    private void inserirDadosNaPosicao(List<String> dados, String delimitador, int coluna, int linha) {
        List<String> dadosSplit = Arrays.asList(String.join(delimitador, dados).split(delimitador));
        inserirDados(dadosSplit, delimitador, coluna, linha);
    }

    private void inserirDadosArquivoNaPosicao(String caminhoArquivo, String delimitador) {
        inserirDadosArquivo(caminhoArquivo, delimitador, posicaoInicialColuna, posicaoInicialLinha);
        resetarPosicao();
    }

    private void inserirDadosArquivoNaPosicao(String caminhoArquivo, String delimitador, int coluna, int linha) {
        try (BufferedReader br = new BufferedReader(new FileReader(caminhoArquivo))) {
            String linhaTexto;
            int numeroLinha = linha;

            while ((linhaTexto = br.readLine()) != null) {
                // Usa Pattern.quote para tratar corretamente o delimitador
                String[] valores = linhaTexto.split(Pattern.quote(delimitador));
                Row linhaPlanilha = sheet.getRow(numeroLinha);
                if (linhaPlanilha == null) {
                    linhaPlanilha = sheet.createRow(numeroLinha);
                }

                for (int numeroColuna = 0; numeroColuna < valores.length; numeroColuna++) {
                    Cell celula = linhaPlanilha.createCell(coluna + numeroColuna);
                    celula.setCellValue(valores[numeroColuna].trim());
                }
                numeroLinha++;
            }
            // Atualiza o índice da última linha inserida
            lastInsertedRowIndex = numeroLinha - 1;
            posicaoInicialLinha = numeroLinha;

        } catch (IOException e) {
            System.out.println("Erro ao ler o arquivo: " + e.getMessage());
        }

        // Após inserir, reseta a flag
        resetarPosicao();
    }

    @Override
    public EstiloCelula aplicarEstilos() {
        EstiloCelula estilo;
        if (intervaloDefinido) {
            estilo = new EstiloCelula(workbook, sheet, posicaoInicialLinha, posicaoInicialColuna, posicaoFinalLinha, posicaoFinalColuna);
            resetarIntervalo();
        } else if (lastInsertedRowIndex == -1) {
            // Nenhuma linha para aplicar estilos, retornar uma instância com rowIndex = -1
            estilo = new EstiloCelula(workbook, sheet, -1, -1);
        } else {
            // Para aplicar estilos a toda a linha, passamos columnIndex como -1
            estilo = new EstiloCelula(workbook, sheet, lastInsertedRowIndex, -1);
        }
        return estilo;
    }

    @Override
    public EstiloCelula aplicarEstilosEmCelula() {
        if (lastInsertedRowIndex == -1 || lastInsertedColIndex == -1) {
            // Nenhuma célula para aplicar estilos, retornar uma instância com rowIndex = -1
            // e columnIndex = -1
            return new EstiloCelula(workbook, sheet, -1, -1);
        }
        return new EstiloCelula(workbook, sheet, lastInsertedRowIndex, lastInsertedColIndex);
    }

    @Override
    public IPlanilha converterEmNumero(String posicaoInicial) {
        CalculosPlanilha.converterEmNumero(sheet, posicaoInicial);
        return this;
    }

    @Override
    public IPlanilha converterEmContabil(String posicaoInicial) {
        CalculosPlanilha.converterEmContabil(sheet, posicaoInicial, workbook);
        return this;
    }

    @Override
    public IPlanilha somarColuna(String posicaoInicial) {
        CalculosPlanilha.somarColuna(sheet, posicaoInicial);
        // Extrair a letra da coluna a partir de posicaoInicial (ex: "J3" -> "J")
        String colunaLetra = posicaoInicial.replaceAll("[0-9]", "");
        this.ultimaLinha(colunaLetra);
        // Resetar lastInsertedColIndex já que estamos lidando com uma coluna inteira
        this.lastInsertedColIndex = -1;
        return this;
    }

    @Override
    public IPlanilha somarColunaComTexto(String posicaoInicial, String texto) {
        CalculosPlanilha.somarColunaComTexto(sheet, posicaoInicial, texto);
        // Extrair a letra da coluna a partir de posicaoInicial (e.g., "J3" -> "J")
        String colunaLetra = posicaoInicial.replaceAll("[0-9]", "");
        this.ultimaLinha(colunaLetra);
        // Resetar lastInsertedColIndex já que estamos lidando com uma linha inteira
        this.lastInsertedColIndex = -1;
        return this;
    }

    @Override
    public EstiloCelula centralizarTudo() {
        return aplicarEstilos().centralizarTudo();
    }

    @Override
    public EstiloCelula redimensionarColunas() {
        return aplicarEstilos().redimensionarColunas();
    }

    @Override
    public EstiloCelula removerLinhasDeGrade() {
        return aplicarEstilos().removerLinhasDeGrade();
    }

    @Override
    public Workbook obterWorkbook() {
        return workbook;
    }

    @Override
    public void salvar(String nomeArquivo) throws IOException {
        try (FileOutputStream arquivoSaida = new FileOutputStream(nomeArquivo)) {
            workbook.write(arquivoSaida);
            System.out.println("Planilha criada com sucesso em: " + nomeArquivo);
        }
    }

    @Override
    public void setDiretorioSaida(String diretorioSaida) {
        this.diretorioSaida = diretorioSaida;
    }

    @Override
    public String getDiretorioSaida() {
        return diretorioSaida;
    }

    /**
     * Implementação do método ultimaLinha que define a última linha com dados na
     * coluna especificada.
     * 
     * @param coluna Letra da coluna (por exemplo, "A", "B", "C", etc.)
     * @return A instância atual de IPlanilha para chamadas encadeadas.
     */
    @Override
    public IPlanilha ultimaLinha(String coluna) {
        // Converter a letra da coluna para o índice (0-based)
        int[] posicao = PosicaoConverter.converterPosicao(coluna + "1"); // Exemplo: "I1"
        int colunaIndex = posicao[0];

        int ultimaLinha = -1;
        for (int i = 0; i <= sheet.getLastRowNum(); i++) {
            Row row = sheet.getRow(i);
            if (row != null) {
                Cell cell = row.getCell(colunaIndex);
                if (cell != null && cell.getCellTypeEnum() != CellType.BLANK) {
                    ultimaLinha = i;
                }
            }
        }

        if (ultimaLinha >= 0) {
            this.lastInsertedRowIndex = ultimaLinha;
        } else {
            // Se nenhuma linha tiver dados, definir para a próxima linha disponível
            this.lastInsertedRowIndex = sheet.getLastRowNum();
        }

        return this;
    }

    /**
     * Converte uma posição no formato "A1" para índices de coluna e linha.
     * 
     * @param posicao A posição em formato "A1", "B3", etc.
     * @return Um array onde o primeiro elemento é o índice da coluna (0-based) e o segundo elemento é o índice da linha (0-based).
     */
    private int[] converterPosicao(String posicao) {
        int coluna = 0;
        int linha = 0;
        for (int i = 0; i < posicao.length(); i++) {
            char ch = posicao.charAt(i);
            if (Character.isLetter(ch)) {
                coluna = coluna * 26 + (Character.toUpperCase(ch) - 'A' + 1);
            } else if (Character.isDigit(ch)) {
                linha = Integer.parseInt(posicao.substring(i)) - 1;
                break;
            }
        }
        return new int[] { coluna - 1, linha };
    }

    /**
     * Reseta as variáveis de posição individual.
     */
    private void resetarPosicao() {
        this.posicaoInicialColuna = 0; // Volta para 'A'
        this.posicaoInicialLinha = 0;   // Volta para '1'
        this.posicaoDefinida = false;   // Reseta a flag
    }

    /**
     * Reseta as variáveis de intervalo.
     */
    private void resetarIntervalo() {
        this.posicaoInicialColuna = 0;
        this.posicaoInicialLinha = 0;
        this.posicaoFinalColuna = 0;
        this.posicaoFinalLinha = 0;
        this.intervaloDefinido = false;
    }
}
