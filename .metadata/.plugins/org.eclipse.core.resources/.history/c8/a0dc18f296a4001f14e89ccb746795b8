package com.abnote.planilhas.impl;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.Arrays;
import java.util.List;
import java.util.regex.Pattern;

import org.apache.poi.ss.usermodel.Cell;
import org.apache.poi.ss.usermodel.CellType;
import org.apache.poi.ss.usermodel.Row;
import org.apache.poi.ss.usermodel.Sheet;
import org.apache.poi.ss.usermodel.Workbook;

import com.abnote.planilhas.estilos.EstiloCelula;
import com.abnote.planilhas.interfaces.IPlanilha;
import com.abnote.planilhas.utils.PosicaoConverter;

public abstract class PlanilhaBase implements IPlanilha {
	protected Workbook workbook;
	protected Sheet sheet;
	private int posicaoInicialColuna = 0;
	private int posicaoInicialLinha = 0;
	private Integer lastInsertedColIndex = -1;
	private String diretorioSaida = "C:\\opt\\tmp\\testePlanilhaSaidas"; // Diretório padrão

	// Rastreia a última linha inserida
	private int lastInsertedRowIndex = -1;

	// Flag para verificar se naCelula foi chamado
	private boolean posicaoDefinida = false;

	protected abstract void inicializarWorkbook();

	@Override
	public void criarPlanilha(String nomeSheet) {
		inicializarWorkbook();
		sheet = workbook.createSheet(nomeSheet);
		// Resetar posição ao criar uma nova planilha
		resetarPosicao();
	}

	@Override
	public void criarSheet(String nomeSheet) {
		if (workbook.getSheet(nomeSheet) != null) {
			throw new IllegalArgumentException("A aba '" + nomeSheet + "' já existe!");
		}
		sheet = workbook.createSheet(nomeSheet);
		// Resetar posição ao criar uma nova sheet
		resetarPosicao();
	}

	@Override
	public void SELECIONAR_SHEET(String nomeSheet) {
		try {
			if (workbook == null) {
				throw new IllegalStateException("Workbook ainda não foi inicializado!");
			}

			sheet = workbook.getSheet(nomeSheet); // Tenta obter a aba pelo nome

			if (sheet == null) {
				throw new IllegalArgumentException("A aba '" + nomeSheet + "' não foi encontrada.");
			}

			// Resetar posição ao selecionar uma nova sheet
			resetarPosicao();

		} catch (IllegalArgumentException e) {
			System.err.println(
					"Erro: A aba '" + nomeSheet + "' não foi criada. Verifique a chamada do método criarSheet().");
			throw e;
		}
	}

	@Override
	public IPlanilha naCelula(String posicao) {
		int coluna = 0;
		int linha = 0;

		for (int i = 0; i < posicao.length(); i++) {
			char ch = posicao.charAt(i);
			if (Character.isLetter(ch)) {
				coluna = coluna * 26 + (Character.toUpperCase(ch) - 'A' + 1);
			} else if (Character.isDigit(ch)) {
				linha = Integer.parseInt(posicao.substring(i)) - 1;
				break;
			}
		}

		this.posicaoInicialColuna = coluna - 1;
		this.posicaoInicialLinha = linha;
		this.posicaoDefinida = true; // Marca que a posição foi definida
		return this;
	}

	@Override
	public IPlanilha noIntervalo(String posicaoInicial, String posicaoFinal) {
	    int[] inicio = converterPosicao(posicaoInicial);
	    int[] fim = converterPosicao(posicaoFinal);

	    // Validação básica para garantir que o intervalo é válido
	    if (inicio[1] > fim[1] || inicio[0] > fim[0]) {
	        throw new IllegalArgumentException("Posição inicial deve ser menor ou igual à posição final.");
	    }

	    // Armazena os índices do intervalo
	    this.posicaoInicialLinha = inicio[1];
	    this.posicaoInicialColuna = inicio[0];
	    this.posicaoFinalLinha = fim[1];
	    this.posicaoFinalColuna = fim[0];
	    this.intervaloDefinido = true; // Flag indicando que um intervalo foi definido

	    return this;
	}
	private int[] converterPosicao(String posicao) {
	    int coluna = 0;
	    int linha = 0;
	    for (int i = 0; i < posicao.length(); i++) {
	        char ch = posicao.charAt(i);
	        if (Character.isLetter(ch)) {
	            coluna = coluna * 26 + (Character.toUpperCase(ch) - 'A' + 1);
	        } else if (Character.isDigit(ch)) {
	            linha = Integer.parseInt(posicao.substring(i)) - 1;
	            break;
	        }
	    }
	    return new int[] { coluna - 1, linha };
	}


	@Override
	public IPlanilha inserirDados(String valor) {
		// Verifica se a posição foi definida por naCelula()
		if (!posicaoDefinida) {
			posicaoInicialColuna = 0; // 'A'
			posicaoInicialLinha = 0; // '1'
		}

		Row linhaAtual = sheet.getRow(posicaoInicialLinha);
		if (linhaAtual == null) {
			linhaAtual = sheet.createRow(posicaoInicialLinha);
		}
		Cell celula = linhaAtual.createCell(posicaoInicialColuna);
		celula.setCellValue(valor);

		lastInsertedRowIndex = posicaoInicialLinha;
		lastInsertedColIndex = posicaoInicialColuna;

		// Após inserir, reseta a flag
		resetarPosicao();

		return this;
	}

	@Override
	public IPlanilha inserirDados(Object dados, String delimitador) {
		if (dados instanceof List) {
			@SuppressWarnings("unchecked")
			List<String> lista = (List<String>) dados;
			inserirDados(lista, delimitador);
		} else if (dados instanceof String) {
			String str = (String) dados;
			if (Files.exists(Paths.get(str))) {
				inserirDadosArquivo(str, delimitador);
			} else {
				// Insere como uma única célula ou divide pelo delimitador
				inserirDados(Arrays.asList(str.split(delimitador)), delimitador);
			}
		} else if (dados instanceof File) {
			inserirDadosArquivo(((File) dados).getPath(), delimitador);
		} else {
			throw new IllegalArgumentException("Tipo de dados não suportado: " + dados.getClass());
		}
		return this;
	}

	@Override
	public IPlanilha inserirDados(List<String> dados) {
		if (!posicaoDefinida) {
			posicaoInicialColuna = 0; // 'A'
			posicaoInicialLinha = 0; // '1'
		}

		Row linhaAtual = sheet.getRow(posicaoInicialLinha);
		if (linhaAtual == null) {
			linhaAtual = sheet.createRow(posicaoInicialLinha);
		}
		for (int i = 0; i < dados.size(); i++) {
			Cell celula = linhaAtual.createCell(posicaoInicialColuna + i);
			celula.setCellValue(dados.get(i));
		}
		lastInsertedRowIndex = posicaoInicialLinha;
		posicaoInicialLinha++;

		// Após inserir, reseta a flag
		resetarPosicao();

		return this;
	}

	@Override
	public IPlanilha inserirDados(List<String> dados, String delimitador) {
		if (!posicaoDefinida) {
			posicaoInicialColuna = 0; // 'A'
			posicaoInicialLinha = 0; // '1'
		}

		Row linhaAtual = sheet.getRow(posicaoInicialLinha);
		if (linhaAtual == null) {
			linhaAtual = sheet.createRow(posicaoInicialLinha);
		}
		for (int i = 0; i < dados.size(); i++) {
			Cell celula = linhaAtual.createCell(posicaoInicialColuna + i);
			celula.setCellValue(dados.get(i));
		}
		lastInsertedRowIndex = posicaoInicialLinha;
		posicaoInicialLinha++;

		// Após inserir, reseta a flag
		resetarPosicao();

		return this;
	}

	@Override
	public IPlanilha inserirDadosArquivo(String caminhoArquivo, String delimitador) {
		// Verifica se a posição foi definida por naCelula()
		if (!posicaoDefinida) {
			posicaoInicialColuna = 0; // 'A'
			posicaoInicialLinha = 0; // '1'
		}

		try (BufferedReader br = new BufferedReader(new FileReader(caminhoArquivo))) {
			String linhaTexto;
			int numeroLinha = posicaoInicialLinha;

			while ((linhaTexto = br.readLine()) != null) {
				// Usa Pattern.quote para tratar corretamente o delimitador
				String[] valores = linhaTexto.split(Pattern.quote(delimitador));
				Row linha = sheet.getRow(numeroLinha);
				if (linha == null) {
					linha = sheet.createRow(numeroLinha);
				}

				for (int numeroColuna = 0; numeroColuna < valores.length; numeroColuna++) {
					Cell celula = linha.createCell(posicaoInicialColuna + numeroColuna);
					celula.setCellValue(valores[numeroColuna].trim());
				}
				numeroLinha++;
			}
			// Atualiza o índice da última linha inserida
			lastInsertedRowIndex = numeroLinha - 1;
			posicaoInicialLinha = numeroLinha;

		} catch (IOException e) {
			System.out.println("Erro ao ler o arquivo: " + e.getMessage());
		}

		// Após inserir, reseta a flag
		resetarPosicao();

		return this;
	}

	private void resetarPosicao() {
		this.posicaoInicialColuna = 0; // Volta para 'A'
		this.posicaoInicialLinha = 0; // Volta para '1'
		this.posicaoDefinida = false; // Reseta a flag
	}

	@Override
	public EstiloCelula aplicarEstilos() {
		if (lastInsertedRowIndex == -1) {
			// Nenhuma linha para aplicar estilos, retornar uma instância com rowIndex = -1
			// e columnIndex = -1
			return new EstiloCelula(workbook, sheet, -1, -1);
		}
		// Para aplicar estilos a toda a linha, passamos columnIndex como -1
		return new EstiloCelula(workbook, sheet, lastInsertedRowIndex, -1);
	}

	@Override
	public EstiloCelula aplicarEstilosEmCelula() {
		if (lastInsertedRowIndex == -1 || lastInsertedColIndex == -1) {
			// Nenhuma célula para aplicar estilos, retornar uma instância com rowIndex = -1
			// e columnIndex = -1
			return new EstiloCelula(workbook, sheet, -1, -1);
		}
		return new EstiloCelula(workbook, sheet, lastInsertedRowIndex, lastInsertedColIndex);
	}

	@Override
	public IPlanilha converterEmNumero(String posicaoInicial) {
		CalculosPlanilha.converterEmNumero(sheet, posicaoInicial);
		return this;
	}

	@Override
	public IPlanilha converterEmContabil(String posicaoInicial) {
		CalculosPlanilha.converterEmContabil(sheet, posicaoInicial, workbook);
		return this;
	}

	@Override
	public IPlanilha somarColuna(String posicaoInicial) {
		CalculosPlanilha.somarColuna(sheet, posicaoInicial);
		// Extrair a letra da coluna a partir de posicaoInicial (ex: "J3" -> "J")
		String colunaLetra = posicaoInicial.replaceAll("[0-9]", "");
		this.ultimaLinha(colunaLetra);
		// Resetar lastInsertedColIndex já que estamos lidando com uma coluna inteira
		this.lastInsertedColIndex = -1;
		return this;
	}

	@Override
	public IPlanilha somarColunaComTexto(String posicaoInicial, String texto) {
		CalculosPlanilha.somarColunaComTexto(sheet, posicaoInicial, texto);
		// Extrair a letra da coluna a partir de posicaoInicial (e.g., "J3" -> "J")
		String colunaLetra = posicaoInicial.replaceAll("[0-9]", "");
		this.ultimaLinha(colunaLetra);
		// Resetar lastInsertedColIndex já que estamos lidando com uma linha inteira
		this.lastInsertedColIndex = -1;
		return this;
	}

	@Override
	public EstiloCelula centralizarTudo() {
		return aplicarEstilos().centralizarTudo();
	}

	@Override
	public EstiloCelula redimensionarColunas() {
		return aplicarEstilos().redimensionarColunas();
	}

	@Override
	public EstiloCelula removerLinhasDeGrade() {
		return aplicarEstilos().removerLinhasDeGrade();
	}

	@Override
	public Workbook obterWorkbook() {
		return workbook;
	}

	@Override
	public void salvar(String nomeArquivo) throws IOException {
		try (FileOutputStream arquivoSaida = new FileOutputStream(nomeArquivo)) {
			workbook.write(arquivoSaida);
			System.out.println("Planilha criada com sucesso em: " + nomeArquivo);
		}
	}

	@Override
	public void setDiretorioSaida(String diretorioSaida) {
		this.diretorioSaida = diretorioSaida;
	}

	@Override
	public String getDiretorioSaida() {
		return diretorioSaida;
	}

	/**
	 * Implementação do método ultimaLinha que define a última linha com dados na
	 * coluna especificada.
	 * 
	 * @param coluna Letra da coluna (por exemplo, "A", "B", "C", etc.)
	 * @return A instância atual de IPlanilha para chamadas encadeadas.
	 */
	@Override
	public IPlanilha ultimaLinha(String coluna) {
		// Converter a letra da coluna para o índice (0-based)
		int[] posicao = PosicaoConverter.converterPosicao(coluna + "1"); // Exemplo: "I1"
		int colunaIndex = posicao[0];

		int ultimaLinha = -1;
		for (int i = 0; i <= sheet.getLastRowNum(); i++) {
			Row row = sheet.getRow(i);
			if (row != null) {
				Cell cell = row.getCell(colunaIndex);
				if (cell != null && cell.getCellTypeEnum() != CellType.BLANK) {
					ultimaLinha = i;
				}
			}
		}

		if (ultimaLinha >= 0) {
			this.lastInsertedRowIndex = ultimaLinha;
		} else {
			// Se nenhuma linha tiver dados, definir para a próxima linha disponível
			this.lastInsertedRowIndex = sheet.getLastRowNum();
		}

		return this;
	}
}
